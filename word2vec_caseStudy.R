
library(shiny)
library(word2vec)
library(tidyverse)
library(shinythemes)

# Server

server = function(input, output, session) {

  setwd("C:/Users/Alex/Desktop/Woerk/Cronbach/Bewerbung/case_study/app")
  
  #import model
  
  model <- read.word2vec(file = "input/german.model", normalize = TRUE)
  
  # define functions
  
  ## 1. blacklist
  
  blacklist <- function(input_list, n_output = 10000) { 
    
    ## generate similar words (gleicher code wie in a1)
    
    # get predictions for all inputted words
    
    sims <- predict(model, newdata = input_list, type = "nearest", top_n = n_output) 
    
    # we want to pick the ones that have highest similarity with any inputted words -> merge list and sort regardless of inputted word
    
    sims_sorted <- do.call(rbind, sims) %>% select(term2, similarity)
    sims_sorted <- sims_sorted[order(sims_sorted$similarity, decreasing = TRUE), ] %>% select(term2)
    sims_sorted <- unlist(sims_sorted, use.names = FALSE)
    
    # should definitely include inputted words
    
    sims_sorted <- c(input_list, sims_sorted)
    
    # pick specified number of suggested words
    
    sims_words <- sims_sorted[1:n_output]
    
    return(sims_words)
    
  }
  
  ## 2. similars 
  
  get_similars <- function(input_list, n_output = 5, blacklist_bool = FALSE, blacklist_input = NULL) {
    
    # first, check if 2-5 words inputted
    
    if(length(input_list) < 2 || length(input_list) > 5) {
      
      warning("Bitte gib 2-5 Woerter ein.")
      
    } else {
      
      # now: get predictions for all inputted words
      
      sims <- predict(model, newdata = input_list, type = "nearest", top_n = 10000) # not a very good solution, but generate enough entries in case of many deletions
      # due to input overlap and blacklist
      
      # we want to pick the ones that have highest similarity with any inputted words -> merge list and sort regardless of inputted word
      
      sims_sorted <- do.call(rbind, sims) %>% select(term2, similarity)
      sims_sorted <- sims_sorted[order(sims_sorted$similarity, decreasing = TRUE), ] %>% select(term2)
      sims_sorted <- unlist(sims_sorted, use.names = FALSE)
      
      # b): exclude words generated by blacklisted words; is optional (only if blacklist non-empty)
      
      if(blacklist_bool == TRUE) {
        
        # stop if no blacklist is supplied
        
        if(is.null(blacklist_input)) {
          
          stop("A blacklist needs to be specified if blacklist_bool is set to TRUE.")
          
          # else, generate blacklist and form setdiff; return 
          
        } else {
          
          sim_blacklist <- blacklist(blacklist_input)
          sim_words <- setdiff(sims_sorted, sim_blacklist)
          
          sim_words <- sim_words[1:n_output]
          
          return(sim_words)
          
        }
        
      } else {
        
        
        # pick specified number of suggested words
        
        sims_words <- sims_sorted[1:n_output]
        
        return(sims_words)
        
      }
    }
  }
  
  ## 3. summary
  
  get_summary <- function(input_list, n_output = 1, blacklist_bool = FALSE, blacklist_input = NULL) {
    
    # again, check if proper number of words and also limit number of output words to 2
    
    if(n_output > 2) {
      
      warning("Please limit search request to 2 words.") 
      
    } else { 
      
      # collapse list into one string 
      
      input_conc <-  paste(input_list, collapse = " ")
      
      # get summary word
      
      input_vec <- doc2vec(model, input_conc)
      sum_list <- predict(model, input_vec, top_n = 10000)[[1]] # not a very good solution, but generate enough entries in case of many deletions
      # due to input overlap and blacklist
      
      # sometimes generates words that are in input list; exclude them
      
      sum_words <- sum_list %>% select(term)
      sum_words <- unlist(sum_words, use.names = FALSE)
      sum_words <- setdiff(sum_words, input_list)
      
      # b): exclude words generated by blacklisted words; is optional (only if blacklist non-empty)
      
      if(blacklist_bool == TRUE) {
        
        if(is.null(blacklist_input)) {
          
          stop("A blacklist needs to be specified if blacklist_bool is set to TRUE.")
          
        } else {
          
          sum_blacklist <- blacklist(blacklist_input)
          sum_words <- setdiff(sum_words, sum_blacklist)
          
          summary_word <- sum_words[1:n_output]
          
          return(summary_word)
          
        }
        
      } else {
        
        
        # pick top n words, return them
        
        summary_word <- sum_words[1:n_output]
        
        return(summary_word)
        
      }
    }
  }
  
  
  # first, change slider based on requested function:
  
  observeEvent(input$type, {
    
    selected_type <- input$type
      
      if(selected_type == "Liste zusammenfassen") {
        
        updateSliderInput(session, "n_output", min = 1, max = 2)
        
      } else {
        
        updateSliderInput(session, "n_output", min = 1, max = 100)
        
      }
        
  })
  
  # show text
  
  observeEvent(input$generateWords, {
    
    # get inputs
    
    type <- input$type
    input_list <- strsplit(input$inputList, split = ", ")[[1]]
    n_output <- input$n_output
    blacklist <- input$blackList
    
    # select function based on input to "type"
    
    
    if(type == "verwandte Woerter") {
      
      selected_function <- get_similars
      
    } else {
      
      selected_function <- get_summary
      
    }
    
    # check if blacklist is supplied and set arguments accordingly
    
    if(blacklist != "") {
      
      blacklist_bool <- TRUE
      blacklist <- strsplit(blacklist, split = ", ")[[1]]
      
    } else {
      
      blacklist_bool <- FALSE
      
    }
    
    # make predictions
    
    predictions <- selected_function(input_list, n_output, blacklist_bool, blacklist)
    
    #update output
    
    output$predictions <- renderText({
      
      predictions
      
    })
    
    
  })
    
} #note: macht den server zu!
  
# UI

ui <- fluidPage(theme = shinytheme("sandstone"),
                
  # title
  
  titlePanel(
    h1("Spielerei mit word2vec")
  ),
  
  # side bar: inputs
  
  sidebarPanel(
   
  selectInput("type", 
              label = "Was kann ich fuer dich tun?",
              choices = c("verwandte Woerter", "Liste zusammenfassen"),
              selected = "verwandte Woerter"),
  
  textInput("inputList", "Liste an Woertern (nach Komma getrennt)."),
  
  textInput("blackList", "Woerter, die nicht drin vorkommen sollen. (optional)"),
  
  sliderInput("n_output", "Anzahl zu generierender Woerter",
              min  = 1, max = 100,
              value = 5),
  
  actionButton("generateWords", "Start")
  ),
  
  
  # Outputs: main panel
  
   mainPanel(
     
     h3("Deine Liste an Woertern ist:"),
  
  h5(textOutput("predictions")
  
    )
  )

)

# put together

shinyApp(ui = ui, server = server)
